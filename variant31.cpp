#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

int main() { //от тук започва главната функция на програмата
	SetConsoleOutputCP(1251); //активира кирилицата в конзолата
	int N; //създадохме променлива N, в които ще вкараме бройката на редовете и стълбовете
	/*
	* с цикъл do-while ще следим дали въведеното числа за редове и стълбове влизат в интервала [3,25]
	*/
	do
	{
		printf("Въведете броят на редовете (цяло число в интевал [3,25]): ");
		scanf("%d", &N); //въвеждаме стойност цяло число за N от конзолата след горния надпис
	}while(N<3 || N>25);
	/*
	* while(N<3 || N>25); - така следим дали въведеното число не е
	* по-малко от 3 или по-голямо от 25
	* и ако е, ще ни кара да въвеждаме стойност наново, т.е. ще изпълнява цикъла докато
	* не въведем число в интевала от 3 до 25
	*/

	float A[N][N]; //двумерен масив, който има N на бр редове и стълбове
	int counter=0; //в counter ще запазим колко са броя на елементите, отговарящо на точка 2 от задан.
	printf("\nВъведете елементите на двумерния масив A:\n");
	//следва цикъл в цикъл за обхождане и въвеждане на елементите на целия масив:
	for(int i=0; i<N; i++)
	{ 	for(int j=0; j<N; j++)
		{ 	printf("A[%d][%d]= ", i, j); //изписва A[0][0]=, A[0][1]=, A[0][2]= и т.н.
			scanf("%f", &A[i][j]); //въвеждаме стойност за елемент на масива от клавиатурата
			if(A[i][j]==(i*j)) counter++; //когато въведем елемент,
			//който е равен на произведението от индексите си, добавяме 1 към counter
		}
	}
 	
 	int i_m=0, j_m=0, multip=0;
	/*В i_m ще присвоим елемента индекса по ред на елемент, който е по-голям от 4,56
	* В i_j ще присвоим елемента индекса по стълб на елемент, който е по-голям от 4,56
	* В multip ще присвоим стойността на елемент, който е по-голям от 4.56 */
	//обхождаме целия масив и търсим число по-голямо от 4.56 и е над главния диагонал:
 	for(int i=0; i<N; i++) 
	{ 	for(int j=0; j<N; j++)
		{ 	if(A[i][j]>4.56 && i<j)
			/*когато индекса на реда е по-малък от този на стълба, значи е над гл. диаг.*/
			{
				i_m=i;
				j_m=j;
				multip=A[i][j];
				break;
			}
		}
	}
 	
 	for(int i=0; i<N; i++) //обхождаме целия масив за да направим умножението по точка 1
	{ 	for(int j=0; j<N; j++)
		{ 	if(A[i][j]>4.56 && i<j)
		 	{
		 	 	if(i!=i_m && j!=j_m) /*дали индексите на елемента са различни от тези на
				елемента, който намерихме горе, че е по-голqм от 4,56 и над гл. диаг
				*/
		  		{
			  		multip*=A[i][j]; //правим умножението
		  		}
		  	}
		}
 	}
 	
 	float B[counter]; /*масив B, който има брой елементи, колкото са броя на елементите на А,
 	отговарящи на точка 2*/
 	int br=0; //ще служи за следенето на индексите на масив B
 	for(int i=0; i<N; i++)
	{ 	for(int j=0; j<N; j++)
		{ 	if(A[i][j]==(i*j)) //дали елемента е равен на произв. от индексите си
 	 		{
 			 	B[br]=A[i][j]; //тогава присвояваме в пореден елемент на масив B
 			 	br++; // добавяме едно към br за да може следващия път,
 			 	//когато намери такъв елемент в A, да го добави в следващия по ред
 			 	// елемент в масив B, т.е. B[0], +1 --> B[1], +1 --> B[2] и т.н.
 		 	}
		}
	}
	
	printf("\nМасив B изглежда така:\n");
	for(int i=0; i<counter; i++) //цикъл for за обхождане на масив B
	{
		printf("%f\t", B[i]); //принтване стойностите на елементите на масив B - \t
	}
 	
 	printf("\n\n");
	//Когато използваме \n в printf това означава нов ред след него. \t е табспейс
	system("pause"); //задържа конзоалта до натискането на клавиш (Press any key to continue . . .)
	return 0; //връща стойност 0 от главната функция на програмата (просто добър навик за писане)
}


